sep() ::= << ; >>
break() ::= << break >>
continue() ::= << goto continue >>
end() ::= << end >>
print(exp) ::= << print(<exp>) >>
return(values) ::= << return <values; separator = ", "> >>

globalVar(names, values) ::= << <names; separator = ", "> = <values; separator = ", "> >>
varDec(names, values) ::= << local <names; separator = ", "> = <values; separator = ", "> >>
varAssign(names, values) ::= << <names; separator = ", "> = <values; separator = ", "> >>

globalFuncDef(name, args) ::= << function <name>(<args; separator = ", ">) >>
funcDef(name, args) ::= << local function <name>(<args; separator = ", ">) >>
anonFuncDef(args) ::= << function (<args; separator = ", ">) >>

prefixExp(name, args) ::= << <if(name)>:<name><endif><args> >>
funcCall(args) ::= << (<args; separator = ", ">) >>

loopEnd() ::= <<
    ::continue::
end >>

do() ::= << do >>
doWhile() ::= << repeat >>
doWhileEnd(cond) ::= <<
    ::continue::
until not (<cond>) >>
while(cond) ::= << while <cond> do >>

for(var, start, end, inc) ::= <<
local <var> = <start>
while <end> do
    <if(inc)><inc><endif> >>
forEnd(inc) ::= <<
    <inc>
end >>
forEach(element, list) ::= << for _, <element> in ipairs(<list>) do >>

if(cond) ::= << if <cond> then >>
elseIf(cond) ::= << elseif <cond> then >>
else() ::= << else >>

unaryOperatorExpr(y, symbol) ::= << <symbol> <y> >>
operatorExpr(x, y, symbol) ::= << <x> <symbol> <y> >>
compoundAssign(x, y, symbol) ::= << <x> = <x> <symbol> <y> >>

len(var) ::= << #<var> >>