import std

f = lambda x { return x * 10 }

xs = map(f, [1, 2, 3, 4, 5])

foreach x in xs
{
	print(x)
}

g = lambda x { if x % 2 == 0 { return true } else { return false } }

ys = filter(g, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

foreach y in ys
{
	print y
}

/*
global g = 10

i, j = 1, 2 + 1

obj = []
obj['x'] = 5

global g_obj = [x = 5, y = 6]

operators = [("+") = 1, ("-") = 2, ("*") = 3, ("/") = 4]

def multiply(x, y)
{
	return x * y
}

global def multiply_g(x)
{
	return x * g
}

def obj.multiply_o(x)
{
	return x * obj.x
}

def obj:multiply_s(x)
{
	return x * self.x
}

def map(f, xs)
{
	for i = 0, i < length xs, i += 1
	{
		xs[i] = f(xs[i])
	}
	
	return xs
}

def filter(b, xs)
{
	ys = []
	i = 0
	
	foreach x in xs
	{
		if b(x)
		{
			i += 1
			ys[i] = x
		}
	}
	
	return ys
}

def filter_skip(b, xs)
{
	ys = []
	i = 0
	
	foreach x in xs
	{
		if b(x) { continue }
		
		i += 1
		ys[i] = x
	}
	
	return ys
}

def split_at(xs, n)
{
	a = []
	b = []
	
	for i = 0, i < length xs, i += 1
	{
		a[i] = xs[i]
		
		if i >= n
		{
			break
		}
	}
	
	for i = 0, i < length xs, i += 1
	{
		b[i] = xs[i + n]
	}
	
	return a, b
}

xs = map(multiply_g, [1, 2, 3, 4, 5])

foreach x in xs
{
	print(x)
}

f = lambda x { if x % 2 == 0 { return true } else { return false } }

ys = filter(f, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

foreach y in ys
{
	print y
}

ys_skip = filter_skip(f, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

foreach y in ys_skip
{
	print y
} 

a, b = split_at([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5)

print "First half:"

foreach ai in a
{
	print ai
}

print "Second half:"

foreach bi in b
{
	print bi
}

var = true
do
{
	var2 = false
	print var
	print var2
}

print var
print var2


str = "refer"
output = ""

global getmetatable('').__index = lambda str i { return string.sub(str, i, i) }
i = 1
j = length str
while str[i] == str[j] && i <= j
{
	output = output ++ str[i]
	i += 1
	j -= 1
}

print output

i = 1
do
{
	i += 1
	print "This will be true twice"
} while i < 3

print 3 ^ 3
print -10 * 10
print true and not true 

print 3 & 5
print 3 | 5
print 3 ~ 5
print 7 >> 1
print 7 << 1
print ~7

var = true
var2 = 1

switch var
{
	case true
	{
		switch var2
		{
			case 1
			{
				print "It works!"
			}
			case 2
			{
				print "???"
			}
			default
			{
				print "Nope!"
			}
		}
	}
	case false
	{
		print "False"
	}
	default
	{
		print "Invalid"
	}
}

i = 0
loops = 0

while i < 10
{
	for j = 0, j < 5, j += 1
	{
		loops += 1
		
		if j % 2 == 0 { continue }
		
		i += 1
	}
}

print loops

def exists(var)
{
	if var is null
	{
		throw NullPointerException
	}
	else
	{
		print "It does exist!"
	}
}

def isCheese(string)
{
	if string is "cheese"
	{
		throw CheeseException
	}
}

try
{
	var = "cheese"
	exists(var)
	isCheese(var)
}
catch NullPointerException
{
	print "NullPointerException: var does not exist!"
}
catch CheeseException
{
	print "Cheese Gromit! Cheese!"
}
finally
{
	print "Not even Wensleydale?"
}
*/

/*
xs = [1, 2, 3, 4, 5]
ys = [6, 7, 8, 9, 10]

ms = merge(xs, ys)

foreach x in filter(lambda x { return x % 30 == 0 }, map(lambda x { return x * 10 }, split(3, 7, ms)))
{
	print x
}

x = 6

if (x == 6)
{
	print -(10 * (-10))
}
else
{
	print "NO"
}
*/

day = [
	MONDAY = 1,
	TUESDAY = 2,
	WEDNESDAY = 3,
	THURSDAY = 4,
	FRIDAY = 5,
	SATURDAY = 6,
	SUNDAY = 7
]

itis = day.WEDNESDAY

if itis == day.WEDNESDAY
{
	print "It is Wednesday my dude."
}

xs = [2, 2]
acc = foldl(lambda x y { return x ^ y }, 6, xs)
print acc

printList(maths.range(5))

print wow:getDescription("calendar", "EventDecline")

foreach category in wow:getCategories()
{
	print category
}

print "Methods of type GET:"

foreach name, _ in wow:getRecordsOnType(wow.methodType.GET)
{
	print name
}

print wow:get("nextAchievementID")
printList(maths.range(2, 5))
printList(maths.range(2, 11, 2))

printList(maths.range(10, 1, -2))